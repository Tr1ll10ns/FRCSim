package frc.robot.simulator.hal.ctre;

import com.ctre.phoenix.CTREJNIWrapper;
import frc.robot.simulator.sim.SimMotController;

/**
 * Sim JNI classes must be structured EXACTLY like their counterpart non-sim JNI classes. If a single field or method is added or removed, the ByteBuddy redefine will fail
 */
public class SimMotControllerJNI extends CTREJNIWrapper {
    public static long Create(int baseArbId) {
        return SimMotController.Create(baseArbId);
    }

    public static long Create2(int deviceID, String model) {
        return SimMotController.Create2(deviceID, model);
    }

    public static int JNI_destroy_MotController(long handle) {
        return SimMotController.JNI_destroy_MotController(handle);
    }

    /**
     * Returns the Device ID
     *
     * @param handle
     *            handle of device.
     *
     * @return Device number.
     */
    public static int GetDeviceNumber(long handle) {
        return SimMotController.GetDeviceNumber(handle);
    }

    public static int GetBaseID(long handle) {
        return SimMotController.GetBaseID(handle);
    }

    /**
     * Sets the demand (output) of the motor controller.
     *
     * @param handle
     *            handle of device.
     * @param mode
     *            Control Mode of the Motor Controller
     * @param demand0
     *            Primary Demand value
     * @param demand1
     *            Secondary Demand value
     **/
    public static void SetDemand(long handle, int mode, int demand0, int demand1) {
        SimMotController.SetDemand(handle, mode, demand0, demand1);
    }

    /**
     * Sets the demand (output) of the motor controller.
     **/
    public static void Set_4(long handle, int mode, double demand0, double demand1, int demand1Type) {
        SimMotController.Set_4(handle, mode, demand0, demand1, demand1Type);
    }

    /**
     * Sets the mode of operation during neutral throttle output.
     *
     * @param handle
     *            handle of device.
     * @param neutralMode
     *            The desired mode of operation when the Controller output
     *            throttle is neutral (ie brake/coast)
     **/
    public static void SetNeutralMode(long handle, int neutralMode) {
        SimMotController.SetNeutralMode(handle, neutralMode);
    }

    /**
     * Sets the phase of the sensor. Use when controller forward/reverse output
     * doesn't correlate to appropriate forward/reverse reading of sensor.
     *
     * @param handle
     *            handle of device.
     * @param PhaseSensor
     *            Indicates whether to invert the phase of the sensor.
     **/
    public static void SetSensorPhase(long handle, boolean PhaseSensor) {
        SimMotController.SetSensorPhase(handle, PhaseSensor);
    }

    /**
     * Inverts the output of the motor controller. LEDs, sensor phase, and limit
     * switches will also be inverted to match the new forward/reverse
     * directions.
     *
     * @param handle
     *            handle of device.
     * @param invert
     *            Invert state to set.
     **/
    public static void SetInverted(long handle, boolean invert) {
        SimMotController.SetInverted(handle, invert);
    }

    /**
     * Inverts the output of the motor controller. LEDs, sensor phase, and limit
     * switches will also be inverted to match the new forward/reverse
     * directions.
     *
     * @param handle
     *            handle of device.
     * @param invert
     *            Invert state to set.
     **/
    public static void SetInverted_2(long handle, int invert) {
        SimMotController.SetInverted_2(handle, invert);
    }

    /**
     * Revert all configurations to factory default values.
     * Use this before your individual config* calls to avoid having to config every single param.
     *
     * Alternatively you can use the configAllSettings routine.
     *
     * @param handle
     *            handle of device.
     * @param timeoutMs
     *            Timeout value in ms. Function will generate error if config is
     *            not successful within timeout.
     * @return Error Code generated by function. 0 indicates no error.
     */
    public static int ConfigFactoryDefault(long handle, int timeoutMs) {
        return SimMotController.ConfigFactoryDefault(handle, timeoutMs);
    }

    /**
     * Configures the open-loop ramp rate of throttle output.
     *
     * @param handle
     *            handle of device.
     * @param secondsFromNeutralToFull
     *            Minimum desired time to go from neutral to full throttle. A
     *            value of '0' will disable the ramp.
     * @param timeoutMs
     *            Timeout value in ms. Function will generate error if config is
     *            not successful within timeout.
     * @return Error Code generated by function. 0 indicates no error.
     */
    public static int ConfigOpenLoopRamp(long handle, double secondsFromNeutralToFull, int timeoutMs) {
        return SimMotController.ConfigOpenLoopRamp(handle, secondsFromNeutralToFull, timeoutMs);
    }

    /**
     * Configures the closed-loop ramp rate of throttle output.
     *
     * @param handle
     *            handle of device.
     * @param secondsFromNeutralToFull
     *            Minimum desired time to go from neutral to full throttle. A
     *            value of '0' will disable the ramp.
     * @param timeoutMs
     *            Timeout value in ms. @see #ConfigOpenLoopRamp
     * @return Error Code generated by function. 0 indicates no error.
     */
    public static int ConfigClosedLoopRamp(long handle, double secondsFromNeutralToFull, int timeoutMs) {
        return SimMotController.ConfigClosedLoopRamp(handle, secondsFromNeutralToFull, timeoutMs);
    }

    /**
     * Configures the forward peak output percentage.
     *
     * @param handle
     *            handle of device.
     * @param percentOut
     *            Desired peak output percentage.
     * @param timeoutMs
     *            Timeout value in ms. @see #ConfigOpenLoopRamp
     * @return Error Code generated by function. 0 indicates no error.
     */
    public static int ConfigPeakOutputForward(long handle, double percentOut, int timeoutMs) {
        return SimMotController.ConfigPeakOutputForward(handle, percentOut, timeoutMs);
    }

    /**
     * Configures the reverse peak output percentage.
     *
     * @param handle
     *            handle of device.
     * @param percentOut
     *            Desired peak output percentage.
     * @param timeoutMs
     *            Timeout value in ms. @see #ConfigOpenLoopRamp
     * @return Error Code generated by function. 0 indicates no error.
     */
    public static int ConfigPeakOutputReverse(long handle, double percentOut, int timeoutMs) {
        return SimMotController.ConfigPeakOutputReverse(handle, percentOut, timeoutMs);
    }

    /**
     * Configures the forward nominal output percentage.
     *
     * @param handle
     *            handle of device.
     * @param percentOut
     *            Nominal (minimum) percent output.
     * @param timeoutMs
     *            Timeout value in ms. @see #ConfigOpenLoopRamp
     * @return Error Code generated by function. 0 indicates no error.
     */
    public static int ConfigNominalOutputForward(long handle, double percentOut, int timeoutMs) {
        return SimMotController.ConfigNominalOutputForward(handle, percentOut, timeoutMs);
    }

    /**
     * Configures the reverse nominal output percentage.
     *
     * @param handle
     *            handle of device.
     * @param percentOut
     *            Nominal (minimum) percent output.
     * @param timeoutMs
     *            Timeout value in ms. @see #ConfigOpenLoopRamp
     * @return Error Code generated by function. 0 indicates no error.
     */
    public static int ConfigNominalOutputReverse(long handle, double percentOut, int timeoutMs) {
        return SimMotController.ConfigNominalOutputReverse(handle, percentOut, timeoutMs);
    }

    /**
     * Configures the output deadband percentage.
     *
     * @param handle
     *            handle of device.
     * @param percentDeadband
     *            Desired deadband percentage. Minimum is 0.1%, Maximum is 25%.
     * @param timeoutMs
     *            Timeout value in ms. @see #ConfigOpenLoopRamp
     * @return Error Code generated by function. 0 indicates no error.
     */
    public static int ConfigNeutralDeadband(long handle, double percentDeadband, int timeoutMs) {
        return SimMotController.ConfigNeutralDeadband(handle, percentDeadband, timeoutMs);
    }

    /**
     * Configures the Voltage Compensation saturation voltage.
     *
     * @param handle
     *            handle of device.
     * @param voltage
     *            TO-DO: Comment me!
     * @param timeoutMs
     *            Timeout value in ms. @see #ConfigOpenLoopRamp
     * @return Error Code generated by function. 0 indicates no error.
     */
    public static int ConfigVoltageCompSaturation(long handle, double voltage, int timeoutMs) {
        return SimMotController.ConfigVoltageCompSaturation(handle, voltage, timeoutMs);
    }

    /**
     * Configures the voltage measurement filter.
     *
     * @param handle
     *            handle of device.
     * @param filterWindowSamples
     *            Number of samples in the rolling average of voltage
     *            measurement.
     * @param timeoutMs
     *            Timeout value in ms. @see #ConfigOpenLoopRamp
     * @return Error Code generated by function. 0 indicates no error.
     */
    public static int ConfigVoltageMeasurementFilter(long handle, int filterWindowSamples, int timeoutMs) {
        return SimMotController.ConfigVoltageMeasurementFilter(handle, filterWindowSamples, timeoutMs);
    }

    /**
     * Enables voltage compensation. If enabled, voltage compensation works in
     * all control modes.
     *
     * Be sure to configure the saturation voltage before enabling this.
     *
     * @param handle
     *            handle of device.
     * @param enable
     *            Enable state of voltage compensation.
     **/
    public static void EnableVoltageCompensation(long handle, boolean enable) {
        SimMotController.EnableVoltageCompensation(handle, enable);
    }

    /**
     * Gets the invert state of the motor controller.
     *
     * @param handle
     *            handle of device.
     * @return The invert state.
     */
    public static boolean GetInverted(long handle) {
        return SimMotController.GetInverted(handle);
    }

    /**
     * Gets the bus voltage seen by the motor controller.
     *
     * @param handle
     *            handle of device.
     * @return The bus voltage value (in volts).
     */
    public static double GetBusVoltage(long handle) {
        return SimMotController.GetBusVoltage(handle);
    }

    /**
     * Gets the output percentage of the motor controller.
     *
     * @param handle
     *            handle of device.
     * @return Output of the motor controller (in percent).
     */
    public static double GetMotorOutputPercent(long handle) {
        return SimMotController.GetMotorOutputPercent(handle);
    }

    /**
     * Gets the output current of the motor controller.
     *
     * @param handle
     *            handle of device.
     * @return Output current (in amps).
     */
    public static double GetOutputCurrent(long handle) {
        return SimMotController.GetOutputCurrent(handle);
    }

    public static double GetSupplyCurrent(long handle) {
        return SimMotController.GetSupplyCurrent(handle);
    }

    public static double GetStatorCurrent(long handle) {
        return SimMotController.GetStatorCurrent(handle);
    }

    /**
     * Gets the temperature of the motor controller.
     *
     * @param handle
     *            handle of device.
     * @return The temperature of the motor controller (in 'C)
     */
    public static double GetTemperature(long handle) {
        return SimMotController.GetTemperature(handle);
    }

    /**
     * Configures the remote feedback filter.
     *
     * @param handle
     *            handle of device.
     * @param deviceID
     *            ID of remote device.
     * @param remoteSensorSource
     *            Type of remote sensor.
     * @param remoteOrdinal
     *            Ordinal of remote source [0-1].
     * @param timeoutMs
     *            Timeout value in ms. @see #ConfigOpenLoopRamp
     * @return Error Code generated by function. 0 indicates no error.
     */
    public static int ConfigRemoteFeedbackFilter(long handle, int deviceID, int remoteSensorSource,
                                                 int remoteOrdinal, int timeoutMs) {
        return SimMotController.ConfigRemoteFeedbackFilter(handle, deviceID, remoteSensorSource, remoteOrdinal, timeoutMs);
    }

    /**
     * Select the feedback device for the motor controller.
     *
     * @param handle
     *            handle of device.
     * @param feedbackDevice
     *            Feedback Device to select.
     * @param pidIdx
     *            Which closed loop to manipulate. 0 for primary, 1 for auxiliary
     * @param timeoutMs
     *            Timeout value in ms. @see #ConfigOpenLoopRamp
     * @return Error Code generated by function. 0 indicates no error.
     */
    public static int ConfigSelectedFeedbackSensor(long handle, int feedbackDevice, int pidIdx, int timeoutMs) {
        return SimMotController.ConfigSelectedFeedbackSensor(handle, feedbackDevice, pidIdx, timeoutMs);
    }

    public static int ConfigSensorTerm(long handle, int sensorTerm, int feedbackDevice, int timeoutMs) {
        return SimMotController.ConfigSensorTerm(handle, sensorTerm, feedbackDevice, timeoutMs);
    }

    /**
     * Get the selected sensor position.
     *
     * @param handle
     *            handle of device.
     * @param pidIdx
     *            Which closed loop to manipulate. 0 for primary, 1 for auxiliary
     * @return Position of selected sensor (in Raw Sensor Units).
     */
    public static int GetSelectedSensorPosition(long handle, int pidIdx) {
        return SimMotController.GetSelectedSensorPosition(handle, pidIdx);
    }

    /**
     * Get the selected sensor velocity.
     *
     * @param handle
     *            handle of device.
     * @param pidIdx
     *            Which closed loop to manipulate. 0 for primary, 1 for auxiliary
     * @return Velocity of selected sensor (in Raw Sensor Units per 100 ms).
     */
    public static int GetSelectedSensorVelocity(long handle, int pidIdx) {
        return SimMotController.GetSelectedSensorVelocity(handle, pidIdx);
    }

    /**
     * Sets the sensor position to the given value.
     *
     * @param handle
     *            handle of device.
     * @param sensorPos
     *            Position to set for the selected sensor (in Raw Sensor Units).
     * @param pidIdx
     *            Which closed loop to manipulate. 0 for primary, 1 for auxiliary
     * @param timeoutMs
     *            Timeout value in ms. @see #ConfigOpenLoopRamp
     * @return Error Code generated by function. 0 indicates no error.
     */
    public static int SetSelectedSensorPosition(long handle, int sensorPos, int pidIdx, int timeoutMs) {
        return SimMotController.SetSelectedSensorPosition(handle, sensorPos, pidIdx, timeoutMs);
    }

    /**
     * Sets the period of the given control frame.
     *
     * @param handle
     *            handle of device.
     * @param frame
     *            Frame whose period is to be changed.
     * @param periodMs
     *            Period in ms for the given frame.
     * @return Error Code generated by function. 0 indicates no error.
     */
    public static int SetControlFramePeriod(long handle, int frame, int periodMs) {
        return SimMotController.SetControlFramePeriod(handle, frame, periodMs);
    }

    /**
     * Sets the period of the given status frame.
     *
     * @param handle
     *            handle of device.
     * @param frame
     *            Frame whose period is to be changed.
     * @param periodMs
     *            Period in ms for the given frame.
     * @param timeoutMs
     *            Timeout value in ms. @see #ConfigOpenLoopRamp
     * @return Error Code generated by function. 0 indicates no error.
     */
    public static int SetStatusFramePeriod(long handle, int frame, int periodMs, int timeoutMs) {
        return SimMotController.SetStatusFramePeriod(handle, frame, periodMs, timeoutMs);
    }

    /**
     * Gets the period of the given status frame.
     *
     * @param handle
     *            handle of device.
     * @param frame
     *            Frame to get the period of.
     * @param timeoutMs
     *            Timeout value in ms. @see #ConfigOpenLoopRamp
     * @return The period of the given status frame.
     */
    public static int GetStatusFramePeriod(long handle, int frame, int timeoutMs) {
        return SimMotController.GetStatusFramePeriod(handle, frame, timeoutMs);
    }

    /**
     * Sets the period over which velocity measurements are taken.
     *
     * @param handle
     *            handle of device.
     * @param period
     *            Desired period for the velocity measurement. @see
     *            com.ctre.phoenix.motorcontrol.VelocityMeasPeriod
     * @param timeoutMs
     *            Timeout value in ms. @see #ConfigOpenLoopRamp
     * @return Error Code generated by function. 0 indicates no error.
     */
    public static int ConfigVelocityMeasurementPeriod(long handle, int period, int timeoutMs) {
        return SimMotController.ConfigVelocityMeasurementPeriod(handle, period, timeoutMs);
    }

    /**
     * Sets the number of velocity samples used in the rolling average velocity
     * measurement.
     *
     * @param handle
     *            handle of device.
     * @param windowSize
     *            Number of samples in the rolling average of velocity
     *            measurement.
     * @param timeoutMs
     *            Timeout value in ms. @see #ConfigOpenLoopRamp
     * @return Error Code generated by function. 0 indicates no error.
     */
    public static int ConfigVelocityMeasurementWindow(long handle, int windowSize, int timeoutMs) {
        return SimMotController.ConfigVelocityMeasurementWindow(handle, windowSize, timeoutMs);
    }

    /**
     * Configures the forward limit switch for a remote source.
     *
     * @param handle
     *            handle of device.
     * @param type
     *            Remote limit switch source. @see com.ctre.phoenix.motorcontrol.LimitSwitchSource
     * @param normalOpenOrClose
     *            Setting for normally open or normally closed.
     * @param deviceID
     *            Device ID of remote source.
     * @param timeoutMs
     *            Timeout value in ms. @see #ConfigOpenLoopRamp
     * @return Error Code generated by function. 0 indicates no error.
     */
    public static int ConfigForwardLimitSwitchSource(long handle, int type, int normalOpenOrClose, int deviceID,
                                                     int timeoutMs) {
        return SimMotController.ConfigForwardLimitSwitchSource(handle, type, normalOpenOrClose, deviceID, timeoutMs);
    }

    /**
     * Configures the reverse limit switch for a remote source.
     *
     * @param handle
     *            handle of device.
     * @param type
     *            Remote limit switch source. @see com.ctre.phoenix.motorcontrol.LimitSwitchSource
     * @param normalOpenOrClose
     *            Setting for normally open or normally closed.
     * @param deviceID
     *            Device ID of remote source.
     * @param timeoutMs
     *            Timeout value in ms. @see #ConfigOpenLoopRamp
     * @return Error Code generated by function. 0 indicates no error.
     */
    public static int ConfigReverseLimitSwitchSource(long handle, int type, int normalOpenOrClose, int deviceID,
                                                     int timeoutMs) {
        return SimMotController.ConfigReverseLimitSwitchSource(handle, type, normalOpenOrClose, deviceID, timeoutMs);
    }

    /**
     * Sets the enable state for limit switches.
     *
     * @param handle
     *            handle of device.
     * @param enable
     *            Enable state for limit switches.
     **/
    public static void OverrideLimitSwitchesEnable(long handle, boolean enable) {
        SimMotController.OverrideLimitSwitchesEnable(handle, enable);
    }

    /**
     * Configures the forward soft limit.
     *
     * @param handle
     *            handle of device.
     * @param forwardSensorLimit
     *            Forward Sensor Position Limit (in Raw Sensor Units).
     * @param timeoutMs
     *            Timeout value in ms. @see #ConfigOpenLoopRamp
     * @return Error Code generated by function. 0 indicates no error.
     */
    public static int ConfigForwardSoftLimitThreshold(long handle, int forwardSensorLimit, int timeoutMs) {
        return SimMotController.ConfigForwardSoftLimitThreshold(handle, forwardSensorLimit, timeoutMs);
    }

    /**
     * Configures the reverse soft limit.
     *
     * @param handle
     *            handle of device.
     * @param reverseSensorLimit
     *            Reverse Sensor Position Limit (in Raw Sensor Units).
     * @param timeoutMs
     *            Timeout value in ms. @see #ConfigOpenLoopRamp
     * @return Error Code generated by function. 0 indicates no error.
     */
    public static int ConfigReverseSoftLimitThreshold(long handle, int reverseSensorLimit, int timeoutMs) {
        return SimMotController.ConfigReverseSoftLimitThreshold(handle, reverseSensorLimit, timeoutMs);
    }

    public static int ConfigForwardSoftLimitEnable(long handle, boolean enable, int timeoutMs) {
        return SimMotController.ConfigForwardSoftLimitEnable(handle, enable, timeoutMs);
    }

    public static int ConfigReverseSoftLimitEnable(long handle, boolean enable, int timeoutMs) {
        return SimMotController.ConfigReverseSoftLimitEnable(handle, enable, timeoutMs);
    }

    /**
     * Sets the enable state for soft limit switches.
     *
     * @param handle
     *            handle of device.
     * @param enable
     *            Enable state for soft limit switches.
     **/
    public static void OverrideSoftLimitsEnable(long handle, boolean enable) {
        SimMotController.OverrideSoftLimitsEnable(handle, enable);
    }

    /**
     * Sets the 'P' constant in the given parameter slot.
     * This is multiplied by closed loop error in sensor units.
     * Note the closed loop output interprets a final value of 1023 as full output.
     * So use a gain of '0.25' to get full output if err is 4096u (Mag Encoder 1 rotation)
     *
     * @param handle
     *            handle of device.
     * @param slotIdx
     *            Parameter slot for the constant.
     * @param value
     *            Value of the P constant.
     * @param timeoutMs
     *            Timeout value in ms. @see #ConfigOpenLoopRamp
     * @return Error Code generated by function. 0 indicates no error.
     */
    public static int Config_kP(long handle, int slotIdx, double value, int timeoutMs) {
        return SimMotController.Config_kP(handle, slotIdx, value, timeoutMs);
    }

    /**
     * Sets the 'I' constant in the given parameter slot.
     * This is multiplied by accumulated closed loop error in sensor units every PID Loop.
     * Note the closed loop output interprets a final value of 1023 as full output.
     * So use a gain of '0.00025' to get full output if err is 4096u for 1000 loops (accumulater holds 4,096,000),
     * [which is equivalent to one CTRE mag encoder rotation for 1000 milliseconds].
     *
     * @param handle
     *            handle of device.
     * @param slotIdx
     *            Parameter slot for the constant.
     * @param value
     *            Value of the I constant.
     * @param timeoutMs
     *            Timeout value in ms. @see #ConfigOpenLoopRamp
     * @return Error Code generated by function. 0 indicates no error.
     */
    public static int Config_kI(long handle, int slotIdx, double value, int timeoutMs) {
        return SimMotController.Config_kI(handle, slotIdx, value, timeoutMs);
    }

    /**
     * Sets the 'D' constant in the given parameter slot.
     *
     * This is multiplied by derivative error (sensor units per PID loop, typically 1ms).
     * Note the closed loop output interprets a final value of 1023 as full output.
     * So use a gain of '250' to get full output if derr is 4096u (Mag Encoder 1 rotation) per 1000 loops (typ 1 sec)
     *
     * @param handle
     *            handle of device.
     * @param slotIdx
     *            Parameter slot for the constant.
     * @param value
     *            Value of the D constant.
     * @param timeoutMs
     *            Timeout value in ms. @see #ConfigOpenLoopRamp
     * @return Error Code generated by function. 0 indicates no error.
     */
    public static int Config_kD(long handle, int slotIdx, double value, int timeoutMs) {
        return SimMotController.Config_kD(handle, slotIdx, value, timeoutMs);
    }

    /**
     * Sets the 'F' constant in the given parameter slot.
     *
     * See documentation for calculation details.
     * If using velocity, motion magic, or motion profile,
     * use (1023 * duty-cycle / sensor-velocity-sensor-units-per-100ms).
     *
     * @param handle
     *            handle of device.
     * @param slotIdx
     *            Parameter slot for the constant.
     * @param value
     *            Value of the F constant.
     * @param timeoutMs
     *            Timeout value in ms. @see #ConfigOpenLoopRamp
     * @return Error Code generated by function. 0 indicates no error.
     */
    public static int Config_kF(long handle, int slotIdx, double value, int timeoutMs) {
        return SimMotController.Config_kF(handle, slotIdx, value, timeoutMs);
    }

    /**
     * Sets the Integral Zone constant in the given parameter slot.
     *
     * @param handle
     *            handle of device.
     * @param slotIdx
     *            Parameter slot for the constant.
     * @param izone
     *            Value of the Integral Zone constant.
     * @param timeoutMs
     *            Timeout value in ms. @see #ConfigOpenLoopRamp
     * @return Error Code generated by function. 0 indicates no error.
     */
    public static int Config_IntegralZone(long handle, int slotIdx, double izone, int timeoutMs) {
        return SimMotController.Config_IntegralZone(handle, slotIdx, izone, timeoutMs);
    }

    /**
     * Sets the allowable closed-loop error in the given parameter slot.
     *
     * @param handle
     *            handle of device.
     * @param slotIdx
     *            Parameter slot for the constant.
     * @param allowableClosedLoopError
     *            Value of the allowable closed-loop error in sensor units (or sensor units per 100ms for velocity).
     * @param timeoutMs
     *            Timeout value in ms. @see #ConfigOpenLoopRamp
     * @return Error Code generated by function. 0 indicates no error.
     */
    public static int ConfigAllowableClosedloopError(long handle, int slotIdx, int allowableClosedLoopError,
                                                     int timeoutMs) {
        return SimMotController.ConfigAllowableClosedloopError(handle, slotIdx, allowableClosedLoopError, timeoutMs);
    }

    /**
     * Sets the maximum integral accumulator in the given parameter slot.
     *
     * @param handle
     *            handle of device.
     * @param slotIdx
     *            Parameter slot for the constant.
     * @param iaccum
     *            Value of the maximum integral accumulator.
     * @param timeoutMs
     *            Timeout value in ms. @see #ConfigOpenLoopRamp
     * @return Error Code generated by function. 0 indicates no error.
     */
    public static int ConfigMaxIntegralAccumulator(long handle, int slotIdx, double iaccum, int timeoutMs) {
        return SimMotController.ConfigMaxIntegralAccumulator(handle, slotIdx, iaccum, timeoutMs);
    }

    /**
     * Sets the integral accumulator.
     *
     * @param handle
     *            handle of device.
     * @param iaccum
     *            Value to set for the integral accumulator.
     * @param timeoutMs
     *            Timeout value in ms. @see #ConfigOpenLoopRamp
     * @param pidIdx
     *            Which closed loop to manipulate. 0 for primary, 1 for auxiliary
     *            secondary loop.
     * @return Error Code generated by function. 0 indicates no error.
     */
    public static int SetIntegralAccumulator(long handle, double iaccum, int pidIdx, int timeoutMs) {
        return SimMotController.SetIntegralAccumulator(handle, iaccum, pidIdx, timeoutMs);
    }

    /**
     * Gets the closed-loop error. The units depend on which control mode is in
     * use.
     *
     * If closed-loop is seeking a target sensor position, closed-loop error is the difference between target
     * and current sensor value (in sensor units.  Example 4096 units per rotation for CTRE Mag Encoder).
     *
     * If closed-loop is seeking a target sensor velocity, closed-loop error is the difference between target
     * and current sensor value (in sensor units per 100ms).
     *
     * If using motion profiling or Motion Magic, closed loop error is calculated against the current target,
     * and not the "final" target at the end of the profile/movement.
     *
     * See Phoenix-Documentation information on units.
     *
     * @param handle
     *            handle of device.
     * @param pidIdx
     *            Which closed loop to manipulate. 0 for primary, 1 for auxiliary
     *            secondary loop.
     * @return Closed-loop error value.
     */
    public static int GetClosedLoopError(long handle, int pidIdx) {
        return SimMotController.GetClosedLoopError(handle, pidIdx);
    }

    /**
     * Gets the iaccum value.
     *
     * @param handle
     *            handle of device.
     * @param pidIdx
     *            Which closed loop to manipulate. 0 for primary, 1 for auxiliary
     *            secondary loop.
     * @return Integral accumulator value.
     */
    public static double GetIntegralAccumulator(long handle, int pidIdx) {
        return SimMotController.GetIntegralAccumulator(handle, pidIdx);
    }

    /**
     * Gets the derivative of the closed-loop error.
     *
     * @param handle
     *            handle of device.
     * @param pidIdx
     *            Which closed loop to manipulate. 0 for primary, 1 for auxiliary
     *            secondary loop.
     * @return Error derivative value.
     */
    public static double GetErrorDerivative(long handle, int pidIdx) {
        return SimMotController.GetErrorDerivative(handle, pidIdx);
    }

    /**
     * Selects which profile slot to use for closed-loop control.
     *
     * @param handle
     *            handle of device.
     * @param slotIdx
     *            Profile slot to select.
     * @param pidIdx
     *            Which closed loop to manipulate. 0 for primary, 1 for auxiliary
     *            secondary loop.
     **/
    public static void SelectProfileSlot(long handle, int slotIdx, int pidIdx) {
        SimMotController.SelectProfileSlot(handle, slotIdx, pidIdx);
    }

    public static int GetActiveTrajectoryPosition(long handle) {
        return SimMotController.GetActiveTrajectoryPosition(handle);
    }

    public static int GetActiveTrajectoryVelocity(long handle) {
        return SimMotController.GetActiveTrajectoryVelocity(handle);
    }

    public static double GetActiveTrajectoryHeading(long handle) {
        return SimMotController.GetActiveTrajectoryHeading(handle);
    }

    public static int GetActiveTrajectoryPosition3(long handle, int pidIdx) {
        return SimMotController.GetActiveTrajectoryPosition3(handle, pidIdx);
    }
    public static int GetActiveTrajectoryVelocity3(long handle, int pidIdx) {
        return SimMotController.GetActiveTrajectoryVelocity3(handle, pidIdx);
    }

    public static double GetActiveTrajectoryArbFeedFwd3(long handle, int pidIdx) {
        return SimMotController.GetActiveTrajectoryArbFeedFwd3(handle, pidIdx);
    }

    /**
     * Sets the Motion Magic Cruise Velocity.
     *
     * @param handle
     *            handle of device.
     * @param sensorUnitsPer100ms
     *            Motion Magic Cruise Velocity (in Raw Sensor Units per 100 ms).
     * @param timeoutMs
     *            Timeout value in ms. @see #ConfigOpenLoopRamp
     * @return Error Code generated by function. 0 indicates no error.
     */
    public static int ConfigMotionCruiseVelocity(long handle, int sensorUnitsPer100ms, int timeoutMs) {
        return SimMotController.ConfigMotionCruiseVelocity(handle, sensorUnitsPer100ms, timeoutMs);
    }

    /**
     * Sets the Motion Magic Acceleration.
     *
     * @param handle
     *            handle of device.
     * @param sensorUnitsPer100msPerSec
     *            Motion Magic Acceleration (in Raw Sensor Units per 100 ms per
     *            second).
     * @param timeoutMs
     *            Timeout value in ms. @see #ConfigOpenLoopRamp
     * @return Error Code generated by function. 0 indicates no error.
     */
    public static int ConfigMotionAcceleration(long handle, int sensorUnitsPer100msPerSec, int timeoutMs) {
        return SimMotController.ConfigMotionAcceleration(handle, sensorUnitsPer100msPerSec, timeoutMs);
    }

    public static int ConfigMotionSCurveStrength(long m_handle, int curveStrength, int timeoutMs) {
        return SimMotController.ConfigMotionSCurveStrength(m_handle, curveStrength, timeoutMs);
    }

    public static int ClearMotionProfileTrajectories(long handle) {
        return SimMotController.ClearMotionProfileTrajectories(handle);
    }

    public static int GetMotionProfileTopLevelBufferCount(long handle) {
        return SimMotController.GetMotionProfileTopLevelBufferCount(handle);
    }

    public static int PushMotionProfileTrajectory(long handle, double position, double velocity,
                                                  double headingDeg, int profileSlotSelect, boolean isLastPoint, boolean zeroPos) {
        return SimMotController.PushMotionProfileTrajectory(handle, position, velocity, headingDeg, profileSlotSelect, isLastPoint, zeroPos);
    }

    public static int PushMotionProfileTrajectory2(long handle, double position, double velocity, double headingDeg,
                                                   int profileSlotSelect0, int profileSlotSelect1, boolean isLastPoint, boolean zeroPos, int durationMs) {
        return SimMotController.PushMotionProfileTrajectory2(handle, position, velocity, headingDeg, profileSlotSelect0, profileSlotSelect1, isLastPoint, zeroPos, durationMs);
    }

    public static int PushMotionProfileTrajectory3(long handle, double position, double velocity, double arbFeedFwd, double auxiliaryPos, double auxiliaryVel, double auxiliaryArbFeedFwd, int profileSlotSelect0, int profileSlotSelect1, boolean isLastPoint, boolean zeroPos0, int timeDur, boolean useAuxPID) {
        return SimMotController.PushMotionProfileTrajectory3(handle, position, velocity, arbFeedFwd, auxiliaryPos, auxiliaryVel, auxiliaryArbFeedFwd, profileSlotSelect0, profileSlotSelect1, isLastPoint, zeroPos0, timeDur, useAuxPID);
    }

    public static int StartMotionProfile(long handle, long streamHandle, int minBufferedPts, int controlMode) {
        return SimMotController.StartMotionProfile(handle, streamHandle, minBufferedPts, controlMode);
    }

    public static boolean IsMotionProfileTopLevelBufferFull(long handle) {
        return SimMotController.IsMotionProfileTopLevelBufferFull(handle);
    }

    public static boolean IsMotionProfileFinished(long handle) {
        return SimMotController.IsMotionProfileFinished(handle);
    }

    public static int ProcessMotionProfileBuffer(long handle) {
        return SimMotController.ProcessMotionProfileBuffer(handle);
    }

    public static int GetMotionProfileStatus(long handle, int[] toFill_9) {
        return SimMotController.GetMotionProfileStatus(handle, toFill_9);
    }

    public static int GetMotionProfileStatus2(long handle, int[] toFill_11) {
        return SimMotController.GetMotionProfileStatus2(handle, toFill_11);
    }

    public static int ClearMotionProfileHasUnderrun(long handle, int timeoutMs) {
        return SimMotController.ClearMotionProfileHasUnderrun(handle, timeoutMs);
    }

    public static int ChangeMotionControlFramePeriod(long handle, int periodMs) {
        return SimMotController.ChangeMotionControlFramePeriod(handle, periodMs);
    }

    public static int ConfigMotionProfileTrajectoryPeriod(long handle, int periodMs, int timeoutMs) {
        return SimMotController.ConfigMotionProfileTrajectoryPeriod(handle, periodMs, timeoutMs);
    }

    public static int ConfigMotionProfileTrajectoryInterpolationEnable(long handle, boolean enable, int timeoutMs) {
        return SimMotController.ConfigMotionProfileTrajectoryInterpolationEnable(handle, enable, timeoutMs);
    }

    public static int ConfigFeedbackNotContinuous(long handle, boolean feedbackNotContinuous, int timeoutMs) {
        return SimMotController.ConfigFeedbackNotContinuous(handle, feedbackNotContinuous, timeoutMs);
    }

    public static int ConfigRemoteSensorClosedLoopDisableNeutralOnLOS(long handle, boolean remoteSensorClosedLoopDisableNeutralOnLOS, int timeoutMs) {
        return SimMotController.ConfigRemoteSensorClosedLoopDisableNeutralOnLOS(handle, remoteSensorClosedLoopDisableNeutralOnLOS, timeoutMs);
    }

    public static int ConfigClearPositionOnLimitF(long handle, boolean clearPositionOnLimitF, int timeoutMs) {
        return SimMotController.ConfigClearPositionOnLimitF(handle, clearPositionOnLimitF, timeoutMs);
    }

    public static int ConfigClearPositionOnLimitR(long handle, boolean clearPositionOnLimitR, int timeoutMs) {
        return SimMotController.ConfigClearPositionOnLimitR(handle, clearPositionOnLimitR, timeoutMs);
    }

    public static int ConfigClearPositionOnQuadIdx(long handle, boolean clearPositionOnQuadIdx, int timeoutMs) {
        return SimMotController.ConfigClearPositionOnQuadIdx(handle, clearPositionOnQuadIdx, timeoutMs);
    }

    public static int ConfigLimitSwitchDisableNeutralOnLOS(long handle, boolean limitSwitchDisableNeutralOnLOS, int timeoutMs) {
        return SimMotController.ConfigLimitSwitchDisableNeutralOnLOS(handle, limitSwitchDisableNeutralOnLOS, timeoutMs);
    }

    public static int ConfigSoftLimitDisableNeutralOnLOS(long handle, boolean softLimitDisableNeutralOnLOS, int timeoutMs) {
        return SimMotController.ConfigSoftLimitDisableNeutralOnLOS(handle, softLimitDisableNeutralOnLOS, timeoutMs);
    }

    public static int ConfigPulseWidthPeriod_EdgesPerRot(long handle, int pulseWidthPeriod_EdgesPerRot, int timeoutMs) {
        return SimMotController.ConfigPulseWidthPeriod_EdgesPerRot(handle, pulseWidthPeriod_EdgesPerRot, timeoutMs);
    }

    public static int ConfigPulseWidthPeriod_FilterWindowSz(long handle, int pulseWidthPeriod_FilterWindowSz, int timeoutMs) {
        return SimMotController.ConfigPulseWidthPeriod_FilterWindowSz(handle, pulseWidthPeriod_FilterWindowSz, timeoutMs);
    }

    /**
     * Gets the last error generated by this object.
     *
     * @param handle
     *            handle of device.
     * @return Last Error Code generated by a function.
     */
    public static int GetLastError(long handle) {
        return SimMotController.GetLastError(handle);
    }

    /**
     * Gets the firmware version of the device.
     *
     * @param handle
     *            handle of device.
     * @return Firmware version of device.
     */
    public static int GetFirmwareVersion(long handle) {
        return SimMotController.GetFirmwareVersion(handle);
    }

    /**
     * Returns true if the device has reset.
     *
     * @param handle
     *            handle of device.
     * @return Has a Device Reset Occurred?
     */
    public static boolean HasResetOccurred(long handle) {
        return SimMotController.HasResetOccurred(handle);
    }

    /**
     * Sets the value of a custom parameter.
     *
     * @param handle
     *            handle of device.
     * @param newValue
     *            Value for custom parameter.
     * @param paramIndex
     *            Index of custom parameter.
     * @param timeoutMs
     *            Timeout value in ms. @see #ConfigOpenLoopRamp
     * @return Error Code generated by function. 0 indicates no error.
     */
    public static int ConfigSetCustomParam(long handle, int newValue, int paramIndex, int timeoutMs) {
        return SimMotController.ConfigSetCustomParam(handle, newValue, paramIndex, timeoutMs);
    }

    /**
     * Gets the value of a custom parameter.
     *
     * @param handle
     *            handle of device.
     * @param paramIndex
     *            Index of custom parameter.
     * @param timoutMs
     *            Timeout value in ms. @see #ConfigOpenLoopRamp
     * @return Value of the custom param.
     */
    public static int ConfigGetCustomParam(long handle, int paramIndex, int timoutMs) {
        return SimMotController.ConfigGetCustomParam(handle, paramIndex, timoutMs);
    }

    /**
     * Sets a parameter.
     *
     * @param handle
     *            handle of device.
     * @param param
     *            Parameter enumeration.
     * @param value
     *            Value of parameter.
     * @param subValue
     *            Subvalue for parameter. Maximum value of 255.
     * @param ordinal
     *            Ordinal of parameter.
     * @param timeoutMs
     *            Timeout value in ms. @see #ConfigOpenLoopRamp
     * @return Error Code generated by function. 0 indicates no error.
     */
    public static int ConfigSetParameter(long handle, int param, double value, int subValue, int ordinal,
                                         int timeoutMs) {
        return SimMotController.ConfigSetParameter(handle, param, value, subValue, ordinal, timeoutMs);
    }

    /**
     * Gets a parameter.
     *
     * @param handle
     *            handle of device.
     * @param param
     *            Parameter enumeration.
     * @param ordinal
     *            Ordinal of parameter.
     * @param timeoutMs
     *            Timeout value in ms. @see #ConfigOpenLoopRamp
     * @return Value of parameter.
     */
    public static double ConfigGetParameter(long handle, int param, int ordinal, int timeoutMs) {
        return SimMotController.ConfigGetParameter(handle, param, ordinal, timeoutMs);
    }

    /**
     * Configures the peak current limit of the motor controller.
     *
     * @param handle
     *            handle of device.
     * @param amps
     *            Peak current limit (in amps).
     * @param timeoutMs
     *            Timeout value in ms. @see #ConfigOpenLoopRamp
     * @return Error Code generated by function. 0 indicates no error.
     */
    public static int ConfigPeakCurrentLimit(long handle, int amps, int timeoutMs) {
        return SimMotController.ConfigPeakCurrentLimit(handle, amps, timeoutMs);
    }

    /**
     * Configures the maximum time allowed at peak current limit of the motor
     * controller.
     *
     * @param handle
     *            handle of device.
     * @param milliseconds
     *            Maximum time allowed at peak current limit (in milliseconds).
     * @param timeoutMs
     *            Timeout value in ms. @see #ConfigOpenLoopRamp
     * @return Error Code generated by function. 0 indicates no error.
     */
    public static int ConfigPeakCurrentDuration(long handle, int milliseconds, int timeoutMs) {
        return SimMotController.ConfigPeakCurrentDuration(handle, milliseconds, timeoutMs);
    }

    /**
     * Configures the continuous current limit.
     *
     * @param handle
     *            handle of device.
     * @param amps
     *            Continuous Current Limit.
     * @param timeoutMs
     *            Timeout value in ms. @see #ConfigOpenLoopRamp
     * @return Error Code generated by function. 0 indicates no error.
     */
    public static int ConfigContinuousCurrentLimit(long handle, int amps, int timeoutMs) {
        return SimMotController.ConfigContinuousCurrentLimit(handle, amps, timeoutMs);
    }

    /**
     * Enables the current limit feature.
     *
     * @param handle
     *            handle of device.
     * @param enable
     *            Enable state of current limit.
     **/
    public static int EnableCurrentLimit(long handle, boolean enable) {
        return SimMotController.EnableCurrentLimit(handle, enable);
    }

    public static int GetAnalogIn(long handle) {
        return SimMotController.GetAnalogIn(handle);
    }

    public static int SetAnalogPosition(long handle, int newPosition, int timeoutMs) {
        return SimMotController.SetAnalogPosition(handle, newPosition, timeoutMs);
    }

    public static int GetAnalogInRaw(long handle) {
        return SimMotController.GetAnalogInRaw(handle);
    }

    public static int GetAnalogInVel(long handle) {
        return SimMotController.GetAnalogInVel(handle);
    }

    public static int GetQuadraturePosition(long handle) {
        return SimMotController.GetQuadraturePosition(handle);
    }

    public static int SetQuadraturePosition(long handle, int newPosition, int timeoutMs) {
        return SimMotController.SetQuadraturePosition(handle, newPosition, timeoutMs);
    }

    public static int GetQuadratureVelocity(long handle) {
        return SimMotController.GetQuadratureVelocity(handle);
    }

    public static int GetPulseWidthPosition(long handle) {
        return SimMotController.GetPulseWidthPosition(handle);
    }

    public static int SetPulseWidthPosition(long handle, int newPosition, int timeoutMs) {
        return SimMotController.SetPulseWidthPosition(handle, newPosition, timeoutMs);
    }

    public static int GetPulseWidthVelocity(long handle) {
        return SimMotController.GetPulseWidthVelocity(handle);
    }

    public static int GetPulseWidthRiseToFallUs(long handle) {
        return SimMotController.GetPulseWidthRiseToFallUs(handle);
    }

    public static int GetPulseWidthRiseToRiseUs(long handle) {
        return SimMotController.GetPulseWidthRiseToRiseUs(handle);
    }

    public static int GetPinStateQuadA(long handle) {
        return SimMotController.GetPinStateQuadA(handle);
    }

    public static int GetPinStateQuadB(long handle) {
        return SimMotController.GetPinStateQuadB(handle);
    }

    public static int GetPinStateQuadIdx(long handle) {
        return SimMotController.GetPinStateQuadIdx(handle);
    }

    public static int IsFwdLimitSwitchClosed(long handle) {
        return SimMotController.IsFwdLimitSwitchClosed(handle);
    }

    public static int IsRevLimitSwitchClosed(long handle) {
        return SimMotController.IsRevLimitSwitchClosed(handle);
    }

    public static int GetFaults(long handle) {
        return SimMotController.GetFaults(handle);
    }

    public static int GetStickyFaults(long handle) {
        return SimMotController.GetStickyFaults(handle);
    }

    public static int ClearStickyFaults(long handle, int timeoutMs) {
        return SimMotController.ClearStickyFaults(handle, timeoutMs);
    }

    public static int SelectDemandType(long handle, int enable) {
        return SimMotController.SelectDemandType(handle, enable);
    }

    public static int SetMPEOutput(long handle, int mpeOutput) {
        return SimMotController.SetMPEOutput(handle, mpeOutput);
    }

    public static int EnableHeadingHold(long handle, int enable) {
        return SimMotController.EnableHeadingHold(handle, enable);
    }

    public static int GetClosedLoopTarget(long handle, int pidIdx) {
        return SimMotController.GetClosedLoopTarget(handle, pidIdx);
    }

    public static int ConfigSelectedFeedbackCoefficient(long handle, double coefficient, int pidIdx, int timeoutMs) {
        return SimMotController.ConfigSelectedFeedbackCoefficient(handle, coefficient, pidIdx, timeoutMs);
    }

    public static int ConfigClosedLoopPeakOutput(long handle, int slotIdx, double percentOut, int timeoutMs) {
        return SimMotController.ConfigClosedLoopPeakOutput(handle, slotIdx, percentOut, timeoutMs);
    }

    public static int ConfigClosedLoopPeriod(long handle, int slotIdx, int loopTimeMs, int timeoutMs) {
        return SimMotController.ConfigClosedLoopPeriod(handle, slotIdx, loopTimeMs, timeoutMs);
    }

    public static int ConfigMotorCommutation(long handle, int motorCommutation, int timeoutMs) {
        return SimMotController.ConfigMotorCommutation(handle, motorCommutation, timeoutMs);
    }

    public static int ConfigGetMotorCommutation(long handle, int timeoutMs) {
        return SimMotController.ConfigGetMotorCommutation(handle, timeoutMs);
    }

    public static int ConfigSupplyCurrentLimit(long handle, double[] params, int timeoutMs) {
        return SimMotController.ConfigSupplyCurrentLimit(handle, params, timeoutMs);
    }

    public static int ConfigStatorCurrentLimit(long handle, double[] params, int timeoutMs) {
        return SimMotController.ConfigStatorCurrentLimit(handle, params, timeoutMs);
    }

    public static int ConfigSupplyCurrentLimitEnable(long handle, boolean enable, int timeoutMs) {
        return SimMotController.ConfigSupplyCurrentLimitEnable(handle, enable, timeoutMs);
    }

    public static int ConfigStatorCurrentLimitEnable(long handle, boolean enable, int timeoutMs) {
        return SimMotController.ConfigStatorCurrentLimitEnable(handle, enable, timeoutMs);
    }

    public static int ConfigBrakeCurrentLimitEnable(long handle, boolean enable, int timeoutMs) {
        return SimMotController.ConfigBrakeCurrentLimitEnable(handle, enable, timeoutMs);
    }

    public static int ConfigGetSupplyCurrentLimit(long handle, double[] toFill, int timeoutMs) {
        return SimMotController.ConfigGetSupplyCurrentLimit(handle, toFill, timeoutMs);
    }

    public static int ConfigGetStatorCurrentLimit(long handle, double[] toFill, int timeoutMs) {
        return SimMotController.ConfigGetStatorCurrentLimit(handle, toFill, timeoutMs);
    }

    public static int SetIntegratedSensorPosition(long handle, double newPos, int timeoutMs) {
        return SimMotController.SetIntegratedSensorPosition(handle, newPos, timeoutMs);
    }

    public static int SetIntegratedSensorPositionToAbsolute(long handle, int timeoutMs) {
        return SimMotController.SetIntegratedSensorPositionToAbsolute(handle, timeoutMs);
    }

    public static double GetIntegratedSensorPosition(long handle) {
        return SimMotController.GetIntegratedSensorPosition(handle);
    }

    public static double GetIntegratedSensorAbsolutePosition(long handle) {
        return SimMotController.GetIntegratedSensorAbsolutePosition(handle);
    }

    public static double GetIntegratedSensorVelocity(long handle) {
        return SimMotController.GetIntegratedSensorVelocity(handle);
    }

    public static int ConfigIntegratedSensorAbsoluteRange(long handle, int absoluteSensorRange, int timeoutMs) {
        return SimMotController.ConfigIntegratedSensorAbsoluteRange(handle, absoluteSensorRange, timeoutMs);
    }

    public static int ConfigIntegratedSensorOffset(long handle, double offsetDegrees, int timeoutMs) {
        return SimMotController.ConfigIntegratedSensorOffset(handle, offsetDegrees, timeoutMs);
    }

    public static int ConfigIntegratedSensorInitializationStrategy(long handle, int initStrategy, int timeoutMs) {
        return SimMotController.ConfigIntegratedSensorInitializationStrategy(handle, initStrategy, timeoutMs);
    }
}

